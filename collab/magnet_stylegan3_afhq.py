# -*- coding: utf-8 -*-
"""MaGNET-Stylegan3 AFHQ

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1F917F3YFdFycxzK0nV_FDzAgmdUMiaJ2
"""

## Code for "MaGNET: Uniform Sampling from Deep Generative Network Manifolds without Retraining"
## https://arxiv.org/abs/2110.08009
## Authors: Ahmed Imtiaz Humayun, Randall Balestriero, Richard Baraniuk
## MIT License
## Copyright (c) 2022 Ahmed Imtiaz Humayun

#@title Download Assets
!git clone https://github.com/NVlabs/stylegan3
!pip install --upgrade --no-cache-dir gdown

# download stylegan3 volume scalars
!gdown https://drive.google.com/uc?id=1FJZ824Avlxe9eJ8sewBGxmU6P3EPTe5c -O ./stylegan3/configt_afhqv2_pixelspace.npz

# model snapshot does not require downloading
# !wget https://api.ngc.nvidia.com/v2/models/nvidia/research/stylegan3/versions/1/files/stylegan3-t-afhqv2-512x512.pkl -O ./stylegan3/stylegan3-t-afhqv2-512x512.pkl

!pip install ninja

#@title Import Utility Functions

def load_svds(svd_path,nmax=250000):
  '''
  Import precomputed svds and corresponding latents
  '''
  with np.load(svd_path) as data:
    svds = data['svds'].astype(np.float64)
    latents = data['latents']

  mask = svds.sum(1) == 0
  svds = svds[np.logical_not(mask)]
  latents = latents[np.logical_not(mask)]

  return latents[:nmax],svds[:nmax]

def imgrid(imarray, cols=10, pad=1,pad_value=0):
  '''
  Display image array in a grid
  '''
  if imarray.dtype != np.uint8:
      raise ValueError('imgrid input imarray must be uint8')
  pad = int(pad)
  assert pad >= 0
  cols = int(cols)
  assert cols >= 1
  N, H, W, C = imarray.shape
  rows = N // cols + int(N % cols != 0)
  batch_pad = rows * cols - N
  assert batch_pad >= 0
  post_pad = [batch_pad, pad, pad, 0]
  pad_arg = [[0, p] for p in post_pad]
  imarray = np.pad(imarray, pad_arg, 'constant', constant_values=pad_value)
  H += pad
  W += pad
  grid = (imarray
        .reshape(rows, cols, H, W, C)
        .transpose(0, 2, 1, 3, 4)
        .reshape(rows*H, cols*W, C))
  if pad:
      grid = grid[:-pad, :-pad]
  return grid

def get_magnet_latents(num_samples,latents,svds,top_k=30,seed=0):
    
    detz = np.exp(np.log(svds[:,:top_k]).sum(1))
        
    proba = detz
    proba = np.clip(proba,1e-60,1e200) # for numerical stability
    print('detz**pol range ',proba.min(),proba.max())
    
    np.random.seed(seed)
    idx = np.random.choice(latents.shape[0], size=num_samples, p=proba / proba.sum(), replace=False)
    return latents[idx,:]


def to_uint8(img):
  '''
  Convert image to uint8
  '''
  img = img*127.5 + 128
  img = np.clip(img,0,255)
  return img.astype(np.uint8)

import sys
sys.path.append('./stylegan3')

import dnnlib
import numpy as np
import PIL.Image
import torch
import legacy

import time
import tqdm
import matplotlib.pyplot as plt

config = 't'             # to change the config/dataset/manifold please  
dataset = 'afhqv2'       # change the download links in the 'download 
manifold = 'pixelspace'  # assets' cell above.

network_pkl = f'https://api.ngc.nvidia.com/v2/models/nvidia/research/stylegan3/versions/1/files/stylegan3-{config}-{dataset}-512x512.pkl'
device = torch.device('cuda')

with dnnlib.util.open_url(network_pkl) as f:
        G = legacy.load_network_pkl(f)['G_ema'].to(device) # type: ignore


latents,svds = load_svds(f'./stylegan3/config{config}_{dataset}_{manifold}.npz')

def generate(z,truncation=1):
    
    label = torch.zeros([z.shape[0], G.c_dim], device=device)
    z = torch.from_numpy(z).to(device)

    img = G(z, label, truncation_psi=truncation,noise_mode='const')
    print(img.shape)
    img = (img.permute(0, 2, 3, 1) * 127.5 + 128).clamp(0, 255).to(torch.uint8)
    return img.cpu().numpy()
    

def create_magnet_montage(rows,cols,truncations,
                         top_k=30,seed=None):
  '''
  Create grid with truncation swept images with both naive and  magnet samples
  '''
  if type(truncations) == float:
    truncations = [truncations]

  cols_per_trunc = cols//len(truncations)
  
  trunc_grid = []
  for i,trunc in tqdm.tqdm(enumerate(truncations),total=len(truncations)):
      
      ## get naive samples
      np.random.seed(seed)
      z = np.random.randn(rows//2*cols_per_trunc,latents.shape[-1])
      imgs = generate(z,trunc)
      imgs1 = imgrid(imgs,cols=cols_per_trunc,pad=10,pad_value=255)

      ## get magnet samples
      z = get_magnet_latents(
          num_samples=rows//2*cols_per_trunc,
          latents=latents,svds=svds,
          top_k=top_k,seed=seed
                          )

      imgs = generate(z,trunc)
      imgs2 = imgrid(imgs,cols=cols_per_trunc,pad=10,pad_value=0)

      trunc_grid.append(imgrid(np.asarray([imgs1,imgs2]),
                               cols=1,
                               pad=30,pad_value=0
                               )
      )
      
  return np.stack(trunc_grid)

rows = 10
cols = 20
truncations = [.3,.5,.7,.9,1]

trunc_grid = create_magnet_montage(
              rows=rows,
              cols=cols,
              top_k=10,
              truncations=truncations
          )

plt.figure(figsize=(27,30))

plt.title(f"From left to right, every {cols//len(truncations)} column contains images with naive sampling (top {rows//2} rows) and magnet sampling (bottom {rows//2} rows) with truncation $\in$ {truncations}",fontsize="15")

plt.imshow(imgrid(trunc_grid,cols=trunc_grid.shape[0],pad=30,pad_value=255))

plt.xticks([]);
plt.yticks([]);